import { cbor_break_sym, _cbor_jmp_base } from '../decode_common/jump.jsy' 
export * from '../decode_common/jump.jsy'

export const _cbor_jmp_async = @{}
  __proto__: _cbor_jmp_base

  // cbor size/value interpreters
  cbor_tiny(as_type) ::
    return function w0_as(ctx, type_b) ::
      return as_type @ ctx, type_b & 0x1f

  cbor_w1(as_type) ::
    return async function w1_as(ctx) ::
      const idx = await ctx.move(1)
      return as_type @ ctx, ctx.u8[idx]

  cbor_w2(as_type) ::
    return async function w2_as(ctx) ::
      const u8 = ctx.u8, idx = await ctx.move(2)
      const v = (u8[idx] << 8) | u8[idx+1]
      return as_type @ ctx, v

  cbor_w4(as_type) ::
    return async function w4_as(ctx) ::
      const u8 = ctx.u8, idx = await ctx.move(4)

      const v = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
      return as_type @ ctx, (v >>> 0) // unsigned int32

  cbor_w8(as_type) ::
    return async function w8_as(ctx) ::
      const u8 = ctx.u8, idx = await ctx.move(8)

      const v_hi = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
      const v_lo = (u8[idx+4] << 24) | (u8[idx+5] << 16) | (u8[idx+6] << 8) | u8[idx+7]
      const u64 = (v_lo >>> 0) + 0x100000000*(v_hi >>> 0)
      return as_type @ ctx, u64


  // basic types

  async as_bytes(ctx, len) ::
    const u8 = ctx.u8, idx = await ctx.move(len)
    return ctx.types.bytes @
      u8.subarray(idx, idx + len)

  async as_utf8(ctx, len) ::
    const u8 = ctx.u8, idx = await ctx.move(len)
    return ctx.types.utf8 @
      u8.subarray(idx, idx + len)

  async as_list(ctx, len) ::
    if 0 === len ::
      return ctx.types.empty_list()

    const accum = ctx.types.list(len)
    for let i=0; i<len; i++ ::
      accum @ i, await ctx.nextValue()

    return undefined === accum.done ? accum.res : accum.done()

  async as_map(ctx, len) ::
    if 0 === len ::
      return ctx.types.empty_map()

    const accum = ctx.types.map(len)
    for let i=0; i<len; i++ ::
      const key = await ctx.nextValue()
      const value = await ctx.nextValue()
      accum @ key, value

    return undefined === accum.done ? accum.res : accum.done()


  // streaming

  async as_stream(ctx, accum) ::
    let i = 0
    while true ::
      const value = await ctx.nextValue()
      if cbor_break_sym === value ::
        return undefined === accum.done ? accum.res : accum.done()

      accum @ i++, value

  async as_pair_stream(ctx, accum) ::
    while true ::
      const key = await ctx.nextValue()
      if cbor_break_sym === key ::
        return undefined === accum.done ? accum.res : accum.done()

      accum @ key, await ctx.nextValue()


  // floating point primitives

  async as_float16(ctx) ::
    const u8 = ctx.u8, idx = await ctx.move(2)
    return ctx.types.float16 @
      u8.subarray(idx, idx+2)

  async as_float32(ctx) ::
    const u8 = ctx.u8, idx = await ctx.move(4)
    return new DataView(u8.buffer, idx, 4).getFloat32(0)

  async as_float64(ctx) ::
    const u8 = ctx.u8, idx = await ctx.move(8)
    return new DataView(u8.buffer, idx, 8).getFloat64(0)


  // tag values

  bind_tag_dispatch(tags_lut) ::
    if 'function' !== typeof tags_lut.get ::
      throw new TypeError @ 'Expected a tags Map'

    return async function as_tag(ctx, tag) ::
      const tag_handler = tags_lut.get(tag)
      if tag_handler ::
        const res = await tag_handler(ctx, tag)
        const body = await ctx.nextValue()
        return undefined === res ? body : res(body)

      return { tag, body: await ctx.nextValue() }


import { as_u8_buffer } from '../u8_utils.jsy'

#IF PLAT_NODEJS
  const {URL} = require('url')

export class U8DecodeCtx ::

  static subclass(types, jmp, unknown) ::
    class U8DecodeCtx_ extends this ::
    const nextValue = U8DecodeCtx_.bindNextValue(jmp, unknown)

    Object.assign @ U8DecodeCtx_.prototype, @{}
      nextValue, types, decode_types: types
    return U8DecodeCtx_


  static fromU8(u8, types) ::
    const inst = new this()
    inst.u8 = u8 = as_u8_buffer(u8)
    inst.idx = 0

    if types !== inst.types ::
      inst.decode_types = inst.types = types
    return inst

  static bindNextValue(jmp, unknown) ::
    if null == unknown ::
      unknown = error_unknown

    return function nextValue() ::
      const type_b = this.u8[ this.idx ++ ]
      if undefined === type_b ::
        throw cbor_done_sym

      if 0 !== this.typestack.length ::
        this.types = this.typestack.pop()

      const decode = jmp[type_b] || unknown
      return decode(this, type_b)

  fromNestedU8(u8) ::
    return this.constructor.fromU8 @
      u8, this.decode_types

  decode() ::
    try ::
      return this.nextValue()
    catch e ::
      if cbor_done_sym === e ::
        e = new Error @ `End of content`
      throw e

  *iter_decode() ::
    try ::
      while true ::
        yield this.nextValue()
    catch e ::
      if cbor_done_sym === e :: return
      throw e

  pushTypes(types) ::
    if 'string' === typeof types ::
      types = this.decode_types[types]

    this.typestack = this.typestack
      .concat @# this.types, types
    this.types = types

  move(byteWidth) ::
    const idx0 = this.idx
    const idx_next = idx0 + byteWidth
    if idx_next >= this.byteLength ::
      throw cbor_eoc_sym
    this.idx = idx_next
    return idx0

U8DecodeCtx.prototype.typestack = []


function error_unknown(ctx, type_b) ::
  throw new Error @ `No CBOR decorder regeistered for ${type_b} (0x${('0'+type_b.toString(16)).slice(-2)})`


export function decode_jump(options, jmp) ::
  jmp = jmp ? jmp.slice() : decode_basic_jump()

  if null == options :: options = {}

  if options.simple ::
    const simple_value = bind_simple_dispatch(options.simple)
    const tiny_simple = _cbor_tiny @ simple_value

    for let i=0xe0; i<= 0xf3; i++ ::
      jmp[i] = tiny_simple

    jmp[0xf8] = _cbor_w1 @ simple_value


  if options.tags ::
    const as_tag = bind_tag_dispatch(options.tags)
    const tiny_tag = _cbor_tiny @ as_tag

    for let i=0xc0; i<= 0xd7; i++ ::
      jmp[0xc0 | i] = tiny_tag

    jmp[0xd8] = _cbor_w1 @ as_tag
    jmp[0xd9] = _cbor_w2 @ as_tag
    jmp[0xda] = _cbor_w4 @ as_tag
    jmp[0xdb] = _cbor_w8 @ as_tag

  return jmp


export function decode_basic_jump() ::
  const as_tag = bind_tag_dispatch @ basic_tags()

  const tiny_pos_int = _cbor_tiny @ as_pos_int
  const tiny_neg_int = _cbor_tiny @ as_neg_int
  const tiny_bytes = _cbor_tiny @ as_bytes
  const tiny_utf8 = _cbor_tiny @ as_utf8
  const tiny_list = _cbor_tiny @ as_list
  const tiny_map = _cbor_tiny @ as_map
  const tiny_tag = _cbor_tiny @ as_tag
  const tiny_simple_repr = _cbor_tiny @ simple_repr

  const jmp = new Array(256)

  for let i=0; i<= 23; i++ ::
    jmp[0x00 | i] = tiny_pos_int
    jmp[0x20 | i] = tiny_neg_int
    jmp[0x40 | i] = tiny_bytes
    jmp[0x60 | i] = tiny_utf8
    jmp[0x80 | i] = tiny_list
    jmp[0xa0 | i] = tiny_map
    jmp[0xc0 | i] = tiny_tag
    jmp[0xe0 | i] = tiny_simple_repr

  const cbor_widths = @[] _cbor_w1, _cbor_w2, _cbor_w4, _cbor_w8
  for let w=0; w< 4; w++ ::
    const i = 24+w, width = cbor_widths[w]
    jmp[0x00 | i] = width @ as_pos_int
    jmp[0x20 | i] = width @ as_neg_int
    jmp[0x40 | i] = width @ as_bytes
    jmp[0x60 | i] = width @ as_utf8
    jmp[0x80 | i] = width @ as_list
    jmp[0xa0 | i] = width @ as_map
    jmp[0xc0 | i] = width @ as_tag

  // streaming data types
  jmp[0x5f] = ctx => as_stream @ ctx, ctx.types.bytes_stream(ctx)
  jmp[0x7f] = ctx => as_stream @ ctx, ctx.types.utf8_stream(ctx)
  jmp[0x9f] = ctx => as_stream @ ctx, ctx.types.list_stream(ctx)
  jmp[0xbf] = ctx => as_pair_stream @ ctx, ctx.types.map_stream(ctx)

  // semantic tag

  // primitives
  jmp[0xf4] = function() :: return false
  jmp[0xf5] = function() :: return true
  jmp[0xf6] = function() :: return null
  jmp[0xf7] = function() :: // undefined
  jmp[0xf8] = _cbor_w1 @ simple_repr
  jmp[0xf9] = float16
  jmp[0xfa] = float32
  jmp[0xfb] = float64
  //jmp[0xfc] = undefined
  //jmp[0xfd] = undefined
  //jmp[0xfe] = undefined
  jmp[0xff] = function () :: return cbor_break_sym

  return jmp


// special token
export const cbor_break_sym = Symbol('CBOR-break')
export const cbor_done_sym = Symbol('CBOR-done')
export const cbor_eoc_sym = Symbol('CBOR-EOC')

// cbor size/value interpreters
function _cbor_tiny(as_type) ::
  return function (ctx, type_b) ::
    return as_type @ ctx, type_b & 0x1f

function _cbor_w1(as_type) ::
  return function (ctx) ::
    const idx = ctx.move(1)
    return as_type @ ctx, ctx.u8[idx]

function _cbor_w2(as_type) ::
  return function (ctx) ::
    const u8 = ctx.u8, idx = ctx.move(2)
    const v = (u8[idx] << 8) | u8[idx+1]
    return as_type @ ctx, v

function _cbor_w4(as_type) ::
  return function (ctx) ::
    const u8 = ctx.u8, idx = ctx.move(4)

    const v = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
    return as_type @ ctx, (v >>> 0) // unsigned int32

function _cbor_w8(as_type) ::
  return function (ctx) ::
    const u8 = ctx.u8, idx = ctx.move(8)

    const v_hi = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
    const v_lo = (u8[idx+4] << 24) | (u8[idx+5] << 16) | (u8[idx+6] << 8) | u8[idx+7]
    const u64 = (v_lo >>> 0) + 0x100000000*(v_hi >>> 0)
    return as_type @ ctx, u64


// basic types

function as_pos_int(ctx, value) ::
  return value

function as_neg_int(ctx, value) ::
  return -1 - value

function as_bytes(ctx, len) ::
  const u8 = ctx.u8, idx = ctx.move(len)
  return ctx.types.bytes @
    u8.subarray(idx, idx + len)

function as_utf8(ctx, len) ::
  const u8 = ctx.u8, idx = ctx.move(len)
  return ctx.types.utf8 @
    u8.subarray(idx, idx + len)

function as_list(ctx, len) ::
  if 0 === len ::
    return ctx.types.empty_list()

  const res = ctx.types.list(len)
  for let i=0; i<len; i++ ::
    res @ false, i, ctx.nextValue()
  return res(true)

function as_map(ctx, len) ::
  if 0 === len ::
    return ctx.types.empty_map()

  const res = ctx.types.map(len)
  for let i=0; i<len; i++ ::
    const key = ctx.nextValue()
    const value = ctx.nextValue()
    res @ false, key, value
  return res(true)


// streaming

function as_stream(ctx, accum) ::
  let i = 0
  while true ::
    const value = ctx.nextValue()
    if cbor_break_sym === value ::
      return accum @ true
    accum @ false, i++, value

function as_pair_stream(ctx, accum) ::
  while true ::
    const key = ctx.nextValue()
    if cbor_break_sym === key ::
      return accum @ true
    accum @ false, key, ctx.nextValue()


// primitives

function float16(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(2)
  return ctx.types.float16 @
    u8.subarray(idx, idx+2)

function float32(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(4)
  return new DataView(u8.buffer, idx, 4).getFloat32(0)

function float64(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(8)
  return new DataView(u8.buffer, idx, 8).getFloat64(0)


// simple values

function simple_repr(ctx, key) ::
  return `simple(${key})`

function bind_simple_dispatch(simple_lut) ::
  if 'function' !== typeof simple_lut.get ::
    throw new TypeError @ 'Expected a simple_value Map'

  return function(ctx, key) ::
    return simple_lut.get(key)


// tag values

function bind_tag_dispatch(tags_lut) ::
  if 'function' !== typeof tags_lut.get ::
    throw new TypeError @ 'Expected a tags Map'

  return function(ctx, tag) ::
    const tag_handler = tags_lut.get(tag)
    if tag_handler ::
      const res = tag_handler(ctx, tag)
      const body = ctx.nextValue()
      return undefined === res ? body : res(body)

    return @{} tag, body: ctx.nextValue()


function basic_tags() ::
  // from https://tools.ietf.org/html/rfc7049#section-2.4

  const tags_lut = new Map()

  // Standard date/time string; see Section 2.4.1
  tags_lut.set @ 0, () => ts_sz => new Date @ ts_sz
  // Epoch-based date/time; see Section 2.4.1
  tags_lut.set @ 1, () => seconds => new Date @ seconds * 1000

  // Positive bignum; see Section 2.4.2
  // tags_lut.set @ 2, () => v => v

  // Negative bignum; see Section 2.4.2
  // tags_lut.set @ 3, () => v => v

  // Decimal fraction; see Section 2.4.3
  // tags_lut.set @ 4, () => v => v

  // Bigfloat; see Section 2.4.3
  // tags_lut.set @ 5, () => v => v

  // Expected conversion to base64url encoding; see Section 2.4.4.2
  // tags_lut.set @ 21, () => v => v

  // Expected conversion to base64 encoding; see Section 2.4.4.2
  // tags_lut.set @ 22, () => v => v

  // Expected conversion to base16 encoding; see Section 2.4.4.2
  // tags_lut.set @ 23, () => v => v

  // Encoded CBOR data item; see Section 2.4.4.1
  tags_lut.set @ 24, ctx => u8 => ctx.types.nestedCBOR(u8, ctx)

  // URI; see Section 2.4.4.3
  tags_lut.set @ 32, () => url_sz => new URL(url_sz)

  // base64url; see Section 2.4.4.3
  //tags_lut.set @ 33, () => v => v

  // base64; see Section 2.4.4.3
  //tags_lut.set @ 34, () => v => v

  // Regular expression; see Section 2.4.4.3
  //tags_lut.set @ 35, () => v => v

  // MIME message; see Section 2.4.4.3
  //tags_lut.set @ 36, () => v => v

  // Self-describe CBOR; see Section 2.4.5
  tags_lut.set @ 55799, () => ::


  // EXTENSIONS

  // CBOR Sets https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  tags_lut.set @ 258, ctx => :: ctx.pushTypes('Set')

  return tags_lut


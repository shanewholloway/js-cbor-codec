import { as_u8_buffer } from '../u8_utils.jsy'

#IF PLAT_NODEJS
  const {URL} = require('url')

export class U8DecodeCtx ::

  static subclass(types, jmp, unknown) ::
    class U8DecodeCtx_ extends this ::
    const nextValue = U8DecodeCtx_.bindNextValue(jmp, unknown)

    Object.assign @ U8DecodeCtx_.prototype, @{}
      nextValue, decode_types: types, types
    return U8DecodeCtx_


  static get fromU8() ::
    const inst0 = new this()
    const inst0_types = inst0.decode_types

    return (u8, types) => ::
      const inst = @{}
        __proto__: inst0
        idx: 0, u8: as_u8_buffer(u8)
        _popTypes: noop

      if types !== inst0_types ::
        inst.decode_types = types
        inst.types = types
      return inst

  static bindNextValue(jmp, unknown) ::
    if null == unknown ::
      unknown = error_unknown

    return function nextValue() ::
      const doneTypes = this._popTypes()

      const type_b = this.u8[ this.idx ++ ]
      if undefined === type_b ::
        throw cbor_done_sym

      const decode = jmp[type_b] || unknown
      const res = decode(this, type_b)

      return undefined === doneTypes
        ? res : doneTypes(res)

  fromNestedU8(u8) ::
    return this.constructor.fromU8 @ u8, this.decode_types

  decode() ::
    try ::
      return this.nextValue()
    catch e ::
      if cbor_done_sym === e ::
        e = new Error @ `End of content`
      throw e

  *iter_decode() ::
    try ::
      while true ::
        yield this.nextValue()
    catch e ::
      if cbor_done_sym === e :: return
      throw e

  pushTypes(overlay_types) ::
    let {types, _popTypes} = this

    if noop === _popTypes ::
      _popTypes = () => ::
        this.types = types

    this._popTypes = @=> ::
      this._popTypes = _popTypes
      this.types = overlay_types
    return types

  move(byteWidth) ::
    const idx0 = this.idx
    const idx_next = idx0 + byteWidth
    if idx_next >= this.byteLength ::
      throw cbor_eoc_sym
    this.idx = idx_next
    return idx0


function noop() ::
function error_unknown(ctx, type_b) ::
  throw new Error @ `No CBOR decorder regeistered for ${type_b} (0x${('0'+type_b.toString(16)).slice(-2)})`


export function decode_jump(options, jmp) ::
  jmp = jmp ? jmp.slice() : decode_basic_jump( new Map() )

  if null == options :: options = {}

  if options.simple ::
    const simple_value = bind_simple_dispatch(options.simple)
    const tiny_simple = _cbor_tiny @ simple_value

    for let i=0xe0; i<= 0xf3; i++ ::
      jmp[i] = tiny_simple

    jmp[0xf8] = _cbor_w1 @ simple_value


  if options.tags ::
    const as_tag = bind_tag_dispatch(options.tags)
    const tiny_tag = _cbor_tiny @ as_tag

    for let i=0xc0; i<= 0xd7; i++ ::
      jmp[0xc0 | i] = tiny_tag

    jmp[0xd8] = _cbor_w1 @ as_tag
    jmp[0xd9] = _cbor_w2 @ as_tag
    jmp[0xda] = _cbor_w4 @ as_tag
    jmp[0xdb] = _cbor_w8 @ as_tag

  return jmp


export function decode_basic_jump(tags_lut) ::
  const as_tag = bind_tag_dispatch @ tags_lut || new Map()

  const tiny_pos_int = _cbor_tiny @ as_pos_int
  const tiny_neg_int = _cbor_tiny @ as_neg_int
  const tiny_bytes = _cbor_tiny @ as_bytes
  const tiny_utf8 = _cbor_tiny @ as_utf8
  const tiny_list = _cbor_tiny @ as_list
  const tiny_map = _cbor_tiny @ as_map
  const tiny_tag = _cbor_tiny @ as_tag
  const tiny_simple_repr = _cbor_tiny @ simple_repr

  const jmp = new Array(256)

  for let i=0; i<= 23; i++ ::
    jmp[0x00 | i] = tiny_pos_int
    jmp[0x20 | i] = tiny_neg_int
    jmp[0x40 | i] = tiny_bytes
    jmp[0x60 | i] = tiny_utf8
    jmp[0x80 | i] = tiny_list
    jmp[0xa0 | i] = tiny_map
    jmp[0xc0 | i] = tiny_tag
    jmp[0xe0 | i] = tiny_simple_repr

  const cbor_widths = @[] _cbor_w1, _cbor_w2, _cbor_w4, _cbor_w8
  for let w=0; w< 4; w++ ::
    const i = 24+w, width = cbor_widths[w]
    jmp[0x00 | i] = width @ as_pos_int
    jmp[0x20 | i] = width @ as_neg_int
    jmp[0x40 | i] = width @ as_bytes
    jmp[0x60 | i] = width @ as_utf8
    jmp[0x80 | i] = width @ as_list
    jmp[0xa0 | i] = width @ as_map
    jmp[0xc0 | i] = width @ as_tag

  // streaming data types
  jmp[0x5f] = ctx => as_stream @ ctx, ctx.types.bytes_stream(ctx)
  jmp[0x7f] = ctx => as_stream @ ctx, ctx.types.utf8_stream(ctx)
  jmp[0x9f] = ctx => as_stream @ ctx, ctx.types.list_stream(ctx)
  jmp[0xbf] = ctx => as_pair_stream @ ctx, ctx.types.map_stream(ctx)

  // semantic tag

  // primitives
  jmp[0xf4] = function() :: return false
  jmp[0xf5] = function() :: return true
  jmp[0xf6] = function() :: return null
  jmp[0xf7] = function() :: // undefined
  jmp[0xf8] = _cbor_w1 @ simple_repr
  jmp[0xf9] = float16
  jmp[0xfa] = float32
  jmp[0xfb] = float64
  //jmp[0xfc] = undefined
  //jmp[0xfd] = undefined
  //jmp[0xfe] = undefined
  jmp[0xff] = function () :: return cbor_break_sym

  return jmp


// special token
export const cbor_break_sym = Symbol('CBOR-break')
export const cbor_done_sym = Symbol('CBOR-done')
export const cbor_eoc_sym = Symbol('CBOR-EOC')

// cbor size/value interpreters
function _cbor_tiny(as_type) ::
  return function w0_as(ctx, type_b) ::
    return as_type @ ctx, type_b & 0x1f

function _cbor_w1(as_type) ::
  return function w1_as(ctx) ::
    const idx = ctx.move(1)
    return as_type @ ctx, ctx.u8[idx]

function _cbor_w2(as_type) ::
  return function w2_as(ctx) ::
    const u8 = ctx.u8, idx = ctx.move(2)
    const v = (u8[idx] << 8) | u8[idx+1]
    return as_type @ ctx, v

function _cbor_w4(as_type) ::
  return function w4_as(ctx) ::
    const u8 = ctx.u8, idx = ctx.move(4)

    const v = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
    return as_type @ ctx, (v >>> 0) // unsigned int32

function _cbor_w8(as_type) ::
  return function (ctx) ::
    const u8 = ctx.u8, idx = ctx.move(8)

    const v_hi = (u8[idx] << 24) | (u8[idx+1] << 16) | (u8[idx+2] << 8) | u8[idx+3]
    const v_lo = (u8[idx+4] << 24) | (u8[idx+5] << 16) | (u8[idx+6] << 8) | u8[idx+7]
    const u64 = (v_lo >>> 0) + 0x100000000*(v_hi >>> 0)
    return as_type @ ctx, u64


// basic types

function as_pos_int(ctx, value) ::
  return value

function as_neg_int(ctx, value) ::
  return -1 - value

function as_bytes(ctx, len) ::
  const u8 = ctx.u8, idx = ctx.move(len)
  return ctx.types.bytes @
    u8.subarray(idx, idx + len)

function as_utf8(ctx, len) ::
  const u8 = ctx.u8, idx = ctx.move(len)
  return ctx.types.utf8 @
    u8.subarray(idx, idx + len)

function as_list(ctx, len) ::
  if 0 === len ::
    return ctx.types.empty_list()

  const accum = ctx.types.list(len)
  for let i=0; i<len; i++ ::
    accum @ i, ctx.nextValue()

  return undefined === accum.done ? accum.res : accum.done()

function as_map(ctx, len) ::
  if 0 === len ::
    return ctx.types.empty_map()

  const accum = ctx.types.map(len)
  for let i=0; i<len; i++ ::
    const key = ctx.nextValue()
    const value = ctx.nextValue()
    accum @ key, value

  return undefined === accum.done ? accum.res : accum.done()


// streaming

function as_stream(ctx, accum) ::
  let i = 0
  while true ::
    const value = ctx.nextValue()
    if cbor_break_sym === value ::
      return undefined === accum.done ? accum.res : accum.done()

    accum @ i++, value

function as_pair_stream(ctx, accum) ::
  while true ::
    const key = ctx.nextValue()
    if cbor_break_sym === key ::
      return undefined === accum.done ? accum.res : accum.done()

    accum @ key, ctx.nextValue()


// primitives

function float16(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(2)
  return ctx.types.float16 @
    u8.subarray(idx, idx+2)

function float32(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(4)
  return new DataView(u8.buffer, idx, 4).getFloat32(0)

function float64(ctx) ::
  const u8 = ctx.u8, idx = ctx.move(8)
  return new DataView(u8.buffer, idx, 8).getFloat64(0)


// simple values

function simple_repr(ctx, key) ::
  return `simple(${key})`

function bind_simple_dispatch(simple_lut) ::
  if 'function' !== typeof simple_lut.get ::
    throw new TypeError @ 'Expected a simple_value Map'

  return function(ctx, key) ::
    return simple_lut.get(key)


// tag values

function bind_tag_dispatch(tags_lut) ::
  if 'function' !== typeof tags_lut.get ::
    throw new TypeError @ 'Expected a tags Map'

  return function(ctx, tag) ::
    const tag_handler = tags_lut.get(tag)
    if tag_handler ::
      const res = tag_handler(ctx, tag)
      const body = ctx.nextValue()
      return undefined === res ? body : res(body)

    return @{} tag, body: ctx.nextValue()


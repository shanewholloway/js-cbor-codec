#IF PLAT_NODEJS
  const { URL } = require('url')

import { useEncoderFor } from './jump.jsy'
import { bind_encoder_context } from './ctx.jsy'

export * from './jump.jsy'
export * from './ctx.jsy'


export class CBOREncoderBasic ::
  static create(stream) :: return new this(stream)
  static encode(v) :: return new this().encode(v)

  constructor(stream) ::
    this.encode = bind_encoder_context(stream)
    this.rebind()

  rebind() ::
    this.encode.rebind(this)
    return this

  withTag(tag) :: return noop

  encoder_map() ::
    if ! Object.hasOwnProperty(this, '_encoder_map') ::
      this._encoder_map = new Map(this._encoder_map)
      this.rebind()
    return this._encoder_map

  simple_map() ::
    if ! Object.hasOwnProperty(this, '_simple_map') ::
      this._simple_map = new Map(this._simple_map)
      this.rebind()
    return this._simple_map


CBOREncoderBasic.prototype._encoder_map = new Map()
function noop() {}


export class CBOREncoder extends CBOREncoderBasic ::

CBOREncoder.prototype._encoder_map = basic_tag_encoders @ new Map()



export function basic_tag_encoders(encoders) ::
  // tag 1 -- Date
  useEncoderFor @ encoders, new Date(), (v, ctx) => ::
    const end_tag = ctx.tag(1)
    ctx.float64(v / 1000.)
    end_tag()

  // tag 32 -- URIs
  useEncoderFor @ encoders, new URL('ws://h'), (v, ctx) => ::
    const end_tag = ctx.tag(32)
    ctx.add_utf8(v.toString())
    end_tag()

  // tag 258 -- Sets (explicit type)
  useEncoderFor @ encoders, new Set(), (v, ctx) => ::
    const end_tag = ctx.tag(258)
    ctx.list(v, v.size)
    end_tag()

  // tag 259 -- Maps (explicit type)
  useEncoderFor @ encoders, new Map(), (v, ctx) => ::
    const end_tag = ctx.tag(259)
    ctx.pairs(v.entries(), v.size)
    end_tag()

  return encoders


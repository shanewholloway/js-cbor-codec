
const objIs = Object.is
export const _obj_kind_ = Function.call.bind @ Object.prototype.toString

export function bind_encode_dispatch(host, ctx) ::
  const @{}
    add_w0, add_w1, add_int,
    float64, add_utf8, add_bytes,
    array, array_stream, object_pairs,
  = ctx

  const lut_basic = new Map(lut_common_types)
  let simple_map, encode_object, lut_types

  // add faster basic type handlers
  lut_basic.set @ _obj_kind_(undefined), @=> :: add_w0(0xf7)
  lut_basic.set @ _obj_kind_(null), @=> :: add_w0(0xf6)
  lut_basic.set @ _obj_kind_(true), v => :: add_w0(v ? 0xf5 : 0xf4)
  lut_basic.set @ _obj_kind_('utf8'), add_utf8
  lut_basic.set @ _obj_kind_([]), array
  lut_basic.set @ _obj_kind_(42), encode_number

  // rebind() binds the following: 
  //   - simple_map, encode_object, lut_types
  //   - '[object Object]' via lut_basic.set @ _obj_kind_({}), encode_object
  rebind()

  encode.rebind = rebind
  return encode


  function rebind() ::
    simple_map = host._simple_map
    lut_types = new Map(lut_basic)

    for const [k,fn] of host._encoder_map.entries() ::
      if 'string' === typeof k && 'function' === typeof fn ::
        lut_types.set @ k, fn

    if host.bind_encode_object ::
      encode_object = host.bind_encode_object(ctx, lut_types)

    else ::
      encode_object = host.encode_object || object_pairs

    lut_types.set @ _obj_kind_({}), encode_object


  function encode(v) ::
    const ty_v = _obj_kind_(v)
    const encoder = lut_types.get(ty_v)
    if undefined !== encoder ::
      encoder(v, ctx)
      return

    // Lookup table for "simple" special instances
    const simple = simple_map.get(v)
    if undefined !== simple ::
      if simple < 24 ::
        add_w0(0xe0 | simple)
      else if simple <= 0xff ::
        add_w1(0xf8, simple)
      else throw new Error @ `Invalid simple value: ${simple}`
      return

    // not '[object Object]', but also not handled explicitly. (e.g. [object Date])
    encode_object(v, ctx)
    return


  function encode_number(v) ::
    if ! Number.isSafeInteger(v) ::
      // floating point or very large numbers
      float64(v)

    else if v > 0 ::
      // pos int
      add_int(0x00, v)

    else if v < 0 ::
      // neg int
      add_int(0x20, -1 - v)

    else if objIs(-0, v) ::
      // negative zero
      ctx.raw_frame @ cu8_f32_neg_zero

    else ::
      // int zero
      add_w0(0)



const cu8_f32_nan = new Uint8Array @# 0xfa, 0x7f, 0xc0, 0, 0
const cu8_f32_pos_infinity = new Uint8Array @# 0xfa, 0x7f, 0x80, 0, 0
const cu8_f32_neg_infinity = new Uint8Array @# 0xfa, 0xff, 0x80, 0, 0
const cu8_f32_neg_zero = new Uint8Array @# 0xfa, 0x80, 0, 0, 0

const lut_common_types = bind_builtin_types @ new Map()

function bind_builtin_types(lut_types) ::
  lut_types.set @ _obj_kind_(undefined), (v, ctx) => :: ctx.add_w0(0xf7)
  lut_types.set @ _obj_kind_(null), (v, ctx) => :: ctx.add_w0(0xf6)
  lut_types.set @ _obj_kind_(true), (v, ctx) => :: ctx.add_w0(v ? 0xf5 : 0xf4)
  lut_types.set @ _obj_kind_('utf8'), (v, ctx) => :: ctx.add_utf8(v)
  lut_types.set @ _obj_kind_([]), (v, ctx) => :: ctx.array(v)
  lut_types.set @ _obj_kind_({}), (v, ctx) => :: ctx.object_pairs(v)

  lut_types.set @ _obj_kind_(NaN), (v, ctx) => :: ctx.raw_frame @ cu8_f32_nan
  lut_types.set @ _obj_kind_(Infinity), (v, ctx) => :: ctx.raw_frame @ cu8_f32_pos_infinity
  lut_types.set @ _obj_kind_(-Infinity), (v, ctx) => :: ctx.raw_frame @ cu8_f32_neg_infinity

  lut_types.set @ _obj_kind_(parseInt), @=> ::
  lut_types.set @ _obj_kind_(Symbol.iterator), @=> ::

  function encode_bytes(v, ctx) :: ctx.add_bytes(v)
  const ab = new ArrayBuffer(0)
  lut_types.set @ _obj_kind_(ab), encode_bytes

  for const ArrayDataKlass of @[]
      Int8Array, Uint8Array, Uint8ClampedArray,
      Int16Array, Uint16Array, Int32Array, Uint32Array,
      Float32Array, Float64Array, DataView ::

    lut_types.set @ _obj_kind_(new ArrayDataKlass(ab)), encode_bytes

  return lut_types


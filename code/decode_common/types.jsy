import { u8_to_utf8, u8_concat } from '../u8_utils.jsy'

export const decode_types = @{}
  __proto__: null

  nested_cbor(u8, ctx) ::
    ctx = ctx.from_nested_u8(u8)
    u8.decode_cbor = () => ctx.decode_cbor()
    return u8

  float16(u8) :: return {'@f2': u8}

  bytes(u8) :: return u8
  bytes_stream: build_bytes

  utf8(u8) :: return u8_to_utf8 @ u8
  utf8_stream: build_utf8


  empty_list() :: return []
  list: build_Array
  list_stream: build_Array

  empty_map() :: return {}
  map: build_Obj
  map_stream: build_Obj



function _with_result_fn(res, fn, done) ::
  fn = fn.bind(res)
  fn.done = done
  fn.res = res
  return fn

function _obj_push(i, v) :: this.push(v)
function _bytes_done() ::
  const res = this.res; this.res = null
  return u8_concat(res)

function build_bytes(ctx) ::
  return _with_result_fn @ [], _obj_push, _bytes_done

function _utf8_done() ::
  const res = this.res; this.res = null
  return res.join('')
function build_utf8(ctx) ::
  return _with_result_fn @ [], _obj_push, _utf8_done



function _with_result(res, fn) ::
  fn = fn.bind(res)
  fn.res = res
  return fn

function _obj_set(k, v) :: this[k] = v

function build_Obj(ctx) ::
  return _with_result @ {}, _obj_set

function build_Array(ctx, len) ::
  const res = len ? new Array(len) : []
  return _with_result @ res, _obj_set


export const decode_Map = @{}
  empty_map() :: return new Map()
  map: build_Map
  map_stream: build_Map

function _map_set(k, v) :: this.set(k, v)
function build_Map(ctx) ::
  return _with_result @ new Map(), _map_set


export const decode_Set = @{}
  empty_list() :: return new Set()
  list: build_Set
  list_stream: build_Set

function _set_add(k, v) :: this.add(v)
function build_Set(ctx) ::
  return _with_result @ new Set(), _set_add


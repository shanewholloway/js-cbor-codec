import { as_u8_buffer } from '../u8_utils.jsy'
import { cbor_done_sym, cbor_eoc_sym } from '../decode_common/u8ctx.jsy'
import { U8DecodeBaseCtx } from '../decode_common/u8ctx.jsy'

export class U8SyncDecodeCtx extends U8DecodeBaseCtx ::
  static bind_decode_api(decoder) ::
    decoder.decode = (u8, opt) =>
      this.from_u8(u8, decoder.types)
        .decode_cbor(opt)

    decoder.iter_decode = (u8, opt) =>
      this.from_u8(u8, decoder.types)
        .iter_decode_cbor(opt)


  static get from_u8() ::
    const inst0 = new this()

    return (u8, types) => ::
      u8 = as_u8_buffer(u8)
      const inst = @{}
        __proto__: inst0
        idx: 0, u8
        _pop_types: inst0._pop_noop
        _loc_proto_: @{}
          get u8() :: return u8.slice(this.idx0, this.idx)

      if types && types !== inst0.types ::
        inst.types = types
      return inst


  static bind_next_value(jmp, unknown) ::
    if null == unknown ::
      unknown = this._error_unknown

    return function next_value() ::
      const doneTypes = this._pop_types()

      const type_b = this.u8[ this.idx ++ ]
      if undefined === type_b ::
        this.idx--
        throw cbor_done_sym

      const decode = jmp[type_b] || unknown
      const res = decode(this, type_b)

      return undefined === doneTypes
        ? res : doneTypes(res)


  decode_cbor(inc_location) ::
    try ::
      if inc_location ::
        const idx0 = this.idx || 0
        const value = this.next_value()
        const idx = this.idx
        return {__proto__: this._loc_proto_, value, idx0, idx}

      return this.next_value()
    catch e ::
      if cbor_done_sym === e ::
        idx = this.idx
        if idx0 == idx ::
          e = new Error @ `End of content`

        else ::
          e = new Error @ `End of partial frame`
          e.cbor_partial = @{}
            __proto__: _loc_proto_,
            idx0, idx, incomplete: true
      throw e
      

  *iter_decode_cbor(inc_location) ::
    let {_loc_proto_} = this
    let idx0, idx = this.idx || 0

    try ::
      while true ::
        idx0 = idx
        const value = this.next_value()
        idx = this.idx

        yield inc_location
          ? { __proto__: _loc_proto_, idx0, idx, value }
          : value

    catch e ::
      if cbor_done_sym === e ::
        idx = this.idx
        if idx0 == idx :: return

        e = new Error @ `End of partial frame`
        e.cbor_partial = @{}
          __proto__: _loc_proto_,
          idx0, idx, incomplete: true
      throw e

  move(count_bytes) ::
    const idx0 = this.idx
    const idx_next = idx0 + count_bytes
    if idx_next >= this.byteLength ::
      throw cbor_eoc_sym
    this.idx = idx_next
    return idx0


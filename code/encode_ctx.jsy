import { utf8_to_u8, as_u8_buffer, u8_concat } from './u8_utils.jsy'
import { bind_encode_dispatch } from './encode_jump.jsy'
export { _obj_kind_ } from './encode_jump.jsy'

const W0=0, W1=24, W2=25, W4=26, W8=27 

export function bind_encoder_context(host, stream) ::
  const blockSize = 65536
  const u8_tip = new Uint8Array(blockSize)
  const dv_tip = new DataView @ u8_tip.buffer

  let idx_frame = 0, idx_next = 0
  if null == stream || true === stream ::
    stream = u8concat_stream()
  else if false == stream ::
    stream = u8array_stream()

  const ctx = @{}
    __proto__: null,
    raw_frame: rawBuffer

    add_w0, add_w1, add_int,
    add_bytes, add_utf8, add_buffer,


    tag(tag, withTag) ::
      add_int(0xc0, tag)
      return withTag || host.withTag(tag)


    float16_short(u16) ::
      const idx = nextBlock(0xf9, 3)
      dv_tip.setUint16(idx, v)

    float32(v) ::
      const idx = nextBlock(0xfa, 5)
      dv_tip.setFloat32(idx, v)

    float64(v) ::
      const idx = nextBlock(0xfb, 9)
      dv_tip.setFloat64(idx, v)



    bytes_stream(iterable) ::
      add_w0(0x5f) // bytes stream
      for const v of iterable ::
        add_bytes(v)
      add_w0(0xff) // break

    utf8_stream(iterable) ::
      add_w0(0x7f) // utf8 stream
      for const v of iterable ::
        add_utf8(v)
      add_w0(0xff) // break


    array(arr) ::
      const len = arr.length
      add_int(0x80, len)
      for let i=0; i<len; i++ ::
        encode(arr[i])

    list(iterable, count) ::
      add_int(0x80, count)

      for const v of iterable ::
        encode(v)

        if 0 >= count -- ::
          break

    list_stream(iterable) ::
      add_w0(0x9f) // list stream

      for const v of iterable ::
        encode(v)

      add_w0(0xff) // break


    object_pairs(v) ::
      const ns = Object.entries(v)
      const count = ns.length

      add_int(0xa0, count)
      for let i=0; i<count; i++ ::
        const e = ns[i]
        encode(e[0])
        encode(e[1])


    pairs(iterable, count) ::
      add_int(0xa0, count)

      for const [k,v] of iterable ::
        encode(k)
        encode(v)

        if 0 >= count -- ::
          break

    pair_stream(iterable) ::
      add_w0(0xbf) // map stream

      for const [k,v] of iterable ::
        encode(k)
        encode(v)

      add_w0(0xff) // break


  const encode = bind_encode_dispatch(host, ctx)
  ctx.encode = encode

  encodeAndFlush.tag = ctx.tag
  return encodeAndFlush

  function add_w0(bkind) ::
    nextBlock(bkind, 1)

  function add_w1(bkind, v8) ::
    const idx = nextBlock(bkind, 2)
    u8_tip[idx] = v8

  function add_int(mask, v) ::
    if v <= 0xffff ::
      if v < 24 :: // tiny
        nextBlock(mask | v, 1)

      else if v <= 0xff ::
        const idx = nextBlock(mask | W1, 2)
        u8_tip[idx] = v

      else ::
        const idx = nextBlock(mask | W2, 3)
        dv_tip.setUint16(idx, v)

    else if v <= 0xffffffff ::
      const idx = nextBlock(mask | W4, 5)
      dv_tip.setUint32(idx, v)

    else ::
      const idx = nextBlock(mask | W8, 9)

      const v_hi = (v / 0x100000000) | 0
      dv_tip.setUint32(idx, v_hi)

      const v_lo = v & 0xffffffff
      dv_tip.setUint32(4+idx, v_lo)
      return

  function add_bytes(v) ::
    add_buffer @ 0x40, as_u8_buffer(v)

  function add_utf8(v) ::
    add_buffer @ 0x60, utf8_to_u8(v)

  function add_buffer(mask, buf) ::
    add_int @ mask, buf.byteLength
    rawBuffer(buf)


  // block paging

  function nextBlock(bkind, frameWidth) ::
    idx_frame = idx_next; idx_next += frameWidth

    u8_tip[idx_frame] = bkind
    if idx_next > blockSize ::
      stream.write @ u8_tip.slice(0, idx_frame)
      idx_frame = 0
      idx_next = frameWidth

    return 1 + idx_frame


  function rawBuffer(buf) ::
    const len = buf.byteLength

    idx_frame = idx_next; idx_next += len
    if idx_next <= blockSize ::
      u8_tip.set(buf, idx_frame)
      return

    if 0 !== idx_frame ::
      stream.write @ u8_tip.slice(0, idx_frame), buf
      idx_frame = 0
      idx_next = len

    stream.write @ buf


  function encodeAndFlush(v) ::
    encode(v)

    if idx_next !== 0 ::
      const blk = u8_tip.slice(0, idx_next)
      idx_frame = idx_next = 0
      return stream.flush(blk)
    else return stream.flush(null)


function u8concat_stream() ::
  let blocks = []
  return @{}
    write(blk) :: blocks.push(blk)
    flush(blk) ::
      if 0 === blocks.length ::
        return blk

      blocks.push(blk)
      const u8 = u8_concat(blocks)
      blocks = []
      return u8

function u8array_stream() ::
  let blocks = []
  return @{}
    write(blk) :: blocks.push(blk)
    flush(blk) ::
      const res = blocks
      blocks = []
      res.push(blk)
      return res

